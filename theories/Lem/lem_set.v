(* Generated by Lem from set.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* Sets in Lem are a bit tricky. On the one hand, we want efficiently executable sets.
   OCaml and Haskell both represent sets by some kind of balancing trees. This means
   that sets are finite and an order on the element type is required. 
   Such sets are constructed by simple, executable operations like inserting or
   deleting elements, union, intersection, filtering etc.

   On the other hand, we want to use sets for specifications. This leads often
   infinite sets, which are specificied in complicated, perhaps even undecidable
   ways.

   The set library in this file, chooses the first approach. It describes 
   *finite* sets with an underlying order. Infinite sets should in the medium
   run be represented by a separate type. Since this would require some significant
   changes to Lem, for the moment also infinite sets are represented using this
   class. However, a run-time exception might occour when using these sets. 
   This problem needs adressing in the future. *)
   

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

Require Import lem_bool.
Require Export lem_bool.
Require Import lem_basic_classes.
Require Export lem_basic_classes.
Require Import lem_maybe.
Require Export lem_maybe.
Require Import lem_function.
Require Export lem_function.
Require Import lem_num.
Require Export lem_num.
Require Import lem_list.
Require Export lem_list.
Require Import lem_set_helpers.
Require Export lem_set_helpers.


(* DPM: sets currently implemented as lists due to mismatch between Coq type
 * class hierarchy and the hierarchy implemented in Lem.
 *)
Require Import Coq.Lists.List.
Require Export Coq.Lists.List.



(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x148_Eq{a: Type} `{SetType a}: Eq (set  a):= {
   isEqual  :=  (set_equal_by setElemCompare);
   isInequal   s1  s2 :=  negb ((set_equal_by setElemCompare s1 s2))
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)
 
Definition filter {a : Type} `{SetType a}  (P : a -> bool ) (s : set a)  : set a:=  let x2  := 
  [] in set_fold (fun (e : a) (x2 : set a) => if P e then set_add e x2 else x2) s x2.
(* [?]: removed value specification. *)

Definition partition0 {a : Type} `{SetType a}  (P : a -> bool ) (s : set a)  : (set a*set a) % type:=  (filter P s, filter (fun (e : a) => negb (P e)) s).
(* [?]: removed value specification. *)

Definition split {a : Type} `{SetType a} `{Ord a}  (p : a) (s : set a)  : (set a*set a) % type:=  (filter (isGreater p) s, filter (isLess p) s).
(* [?]: removed value specification. *)

Definition splitMember {a : Type} `{SetType a} `{Ord a}  (p : a) (s : set a)  : (set a*bool *set a) % type:=  (filter (isLess p) s, (set_member_by setElemCompare p s), filter (isGreater p) s).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition bigunion {a : Type} `{SetType a}  (bs : set (set a))  : set a:=  let x2  := 
  [] in set_fold
   (fun (s : set a) (x2 : set a) =>
      set_fold
        (fun (x : a) (x2 : set a) => if true then set_add x x2 else x2) 
      s x2) bs x2.
(* [?]: removed value specification. *)

Definition bigintersection {a : Type} `{SetType a}  (bs : set (set a))  : set a:=  let x2  := 
  [] in set_fold
   (fun (x : a) (x2 : set a) =>
      if set_for_all (fun (s : set a) => (set_member_by setElemCompare x s))
           bs then set_add x x2 else x2) (bigunion bs) x2.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)
 (* before image *)
Definition map {a b : Type} `{SetType a} `{SetType b}  (f : a -> b) (s : set a)  : set b:=  let x2  := 
  [] in set_fold (fun (e : a) (x2 : set b) => if true then set_add (f e) x2 else x2)
   s x2.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition setMapMaybe {a b : Type} `{SetType a} `{SetType b}  (f : a -> option b ) (s : set a)  : set b:=  
  bigunion (map (fun (x : a) => match ( f x) with  
                        | Some y  => set_singleton y 
                        | None => set_empty
                        end) s).
(* [?]: removed value specification. *)

Definition removeMaybe {a : Type} `{SetType a}  (s : set (option a ))  : set a:=  setMapMaybe (fun (x : option a ) => x) s.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 

Definition sigma {a b : Type} `{SetType a} `{SetType b}  (sa : set a) (sb : a -> set b)  : set ((a*b) % type):= (* XXX: comp binding *). *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition cross {a b : Type} `{SetType a} `{SetType b}  (s1 : set a) (s2 : set b)  : set ((a*b) % type):=  let x2  := 
  [] in set_fold
   (fun (e1 : a) (x2 : set ((a*b) % type)) =>
      set_fold
        (fun (e2 : b) (x2 : set ((a*b) % type)) =>
           if true then set_add (e1, e2) x2 else x2) s2 x2) s1 x2.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Program Fixpoint leastFixedPoint {a : Type} `{SetType a}  (bound : nat ) (f : set a -> set a) (x : set a)  : set a:= 
  match ( bound) with 
  | 0%nat => x
  |S (bound') => let fx  := f x in
                  if (set_subset_by setElemCompare fx x) then x
                  else leastFixedPoint bound' f ( (set_union_by setElemCompare fx x))
  end. 

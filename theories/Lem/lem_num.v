(* Generated by Lem from num.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.



Require Import lem_bool.
Require Export lem_bool.
Require Import lem_basic_classes.
Require Export lem_basic_classes.



Require Import Coq.Numbers.BinNums.
Require Export Coq.Numbers.BinNums.
Require Import Coq.ZArith.BinInt.
Require Export Coq.ZArith.BinInt.
Require Import Coq.ZArith.Zpower.
Require Export Coq.ZArith.Zpower.
Require Import Coq.ZArith.Zdiv.
Require Export Coq.ZArith.Zdiv.
Require Import Coq.ZArith.Zmax.
Require Export Coq.ZArith.Zmax.
Require Import Coq.Reals.Rsqrt_def.
Require Export Coq.Reals.Rsqrt_def.
Require Import NArith.
Require Export NArith.

Require Import Coq.QArith.Qabs.
Require Export Coq.QArith.Qabs.
Require Import Coq.QArith.Qminmax.
Require Export Coq.QArith.Qminmax.
Require Import Coq.QArith.Qround.
Require Export Coq.QArith.Qround.
Require Import Coq.Reals.ROrderedType.
Require Export Coq.Reals.ROrderedType.
Require Import Coq.Reals.Rbase.
Require Export Coq.Reals.Rbase.
Require Import Coq.Reals.Rfunctions.
Require Export Coq.Reals.Rfunctions.

(* 

 *)

(* ========================================================================== *)
(* Syntactic type-classes for common operations                               *)
(* ========================================================================== *)

(* Typeclasses can be used as a mean to overload constants like "+", "-", etc *)

Class  NumNegate (a: Type): Type := {  
  numNegate: a ->a
}. 
Notation " X '~' Y" := (numNegate X Y) (at level 70, no associativity).


Class  NumAbs (a: Type): Type := {  
  abs: a ->a
}. 


Class  NumAdd (a: Type): Type := {  
  numAdd: a ->a ->a
}.
Notation " X '+' Y" := (numAdd X Y) (at level 50, left associativity).


Class  NumMinus (a: Type): Type := {  
  numMinus: a ->a ->a
}.
Notation " X '-' Y" := (numMinus X Y) (at level 50, left associativity).


Class  NumMult (a: Type): Type := {  
  numMult: a ->a ->a
}.
Notation " X '*' Y" := (numMult X Y) (at level 40, left associativity).


Class  NumPow (a: Type): Type := {  
  numPow: a -> nat ->a
}.
Notation " X '**' Y" := (numPow X Y) (at level 70, no associativity).


Class  NumDivision (a: Type): Type := {  
  numDivision: a ->a ->a
}.
Notation " X '/' Y" := (numDivision X Y) (at level 40, left associativity).


Class  NumIntegerDivision (a: Type): Type := {  
  numIntegerDivision: a ->a ->a
}.
Notation " X 'div' Y" := (numIntegerDivision X Y) (at level 70, no associativity).



Class  NumRemainder (a: Type): Type := {  
  numRemainder: a ->a ->a
}.
Notation " X 'mod' Y" := (numRemainder X Y) (at level 40, no associativity).


Class  NumSucc (a: Type): Type := {  
  succ: a ->a
}.


Class  NumPred (a: Type): Type := {  
  pred: a ->a
}.

(*  


(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(* unbounded size natural numbers *)
Inductive natural : Type := .
Definition natural_default: natural  := DAEMON. *)
(* 


(* ----------------------- *)
(* int                     *)
(* ----------------------- *)

(* bounded size integers with uncertain length *)

Inductive int : Type := .
Definition int_default: int  := DAEMON. *)
(* 


(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(* unbounded size integers *)

Inductive integer : Type := .
Definition integer_default: integer  := DAEMON. *)
(* 

(* ----------------------- *)
(* bint                    *)
(* ----------------------- *)

(* TODO the bounded ints are only partially implemented, use with care. *)

(* 32 bit integers *)
Inductive int32 : Type := .
Definition int32_default: int32  := DAEMON. *)
(*  

(* 64 bit integers *)
Inductive int64 : Type := .
Definition int64_default: int64  := DAEMON. *)
(*  


(* ----------------------- *)
(* rational                *)
(* ----------------------- *)

(* unbounded size and precision rational numbers *)

Inductive rational : Type := .
Definition rational_default: rational  := DAEMON. *)
(*  (* ???: better type for this in HOL? *)


(* ----------------------- *)
(* real                    *)
(* ----------------------- *)

(* real numbers *)
(* Note that for OCaml, this is mapped to floats with 64 bits. *)

Inductive real : Type := .
Definition real_default: real  := DAEMON. *)
(*  (* ???: better type for this in HOL? *)


(* ----------------------- *)
(* double                  *)
(* ----------------------- *)

(* double precision floating point (64 bits) *)

Inductive float64 : Type := .
Definition float64_default: float64  := DAEMON. *)
(*  (* ???: better type for this in HOL? *)

Inductive float32 : Type := .
Definition float32_default: float32  := DAEMON. *)
(* [?]: removed value specification. *)

(* 

Instance x142_Numeral : Numeral nat := {
   fromNumeral   n :=   n
}.
 *)
(* [?]: removed value specification. *)

Require Import DecidableClass.
Definition beq_nat := fun (a b: nat)=> decide (a=b).
(* [?]: removed top-level value definition. *)
Instance x141_Eq : Eq nat := {
   isEqual  :=  beq_nat;
   isInequal   n1  n2 :=  negb (beq_nat n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x140_Ord : Ord nat := {
   compare  :=  (genericCompare nat_ltb beq_nat);
   isLess  :=  nat_ltb;
   isLessEqual  :=  nat_lteb;
   isGreater  :=  nat_gtb;
   isGreaterEqual  :=  nat_gteb
}.


Instance x139_SetType : SetType nat := {
   setElemCompare  :=  (genericCompare nat_ltb beq_nat)
}.

(* [?]: removed value specification. *)


Instance x138_NumAdd : NumAdd nat := {
   numAdd  :=  Coq.Init.Peano.plus
}.

(* [?]: removed value specification. *)


Instance x137_NumMinus : NumMinus nat := {
   numMinus  :=  Coq.Init.Peano.minus
}.

(* [?]: removed value specification. *)

(* 
Definition natSucc  (n : nat )  : nat :=  instance_Num_NumAdd_nat.+ n 1%nat. *)
Instance x136_NumSucc : NumSucc nat := {
   succ  :=  S
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x135_NumPred : NumPred nat := {
   pred  :=  Coq.Init.Peano.pred
}.

(* [?]: removed value specification. *)


Instance x134_NumMult : NumMult nat := {
   numMult  :=  Coq.Init.Peano.mult
}.

(* [?]: removed value specification. *)


Instance x133_NumIntegerDivision : NumIntegerDivision nat := { 
   numIntegerDivision  :=  Nat.div
}.


Instance x132_NumDivision : NumDivision nat := { 
   numDivision  :=  Nat.div
}.

(* [?]: removed value specification. *)


Instance x131_NumRemainder : NumRemainder nat := { 
   numRemainder  :=  Nat.modulo
}.

(* [?]: removed value specification. *)

(* 
Program Fixpoint gen_pow_aux {a : Type}   (mul : a ->  a ->  a)  (a : a)  (b : a)  (e : nat )  : a:= 
   match ( e) with 
     | 0%nat => a (* cannot happen, call discipline guarentees e >= 1 *)
     | 1%nat => mul a b
     |(  S (S (e'))) => let e'' := instance_Num_NumDivision_nat./ e 2%nat in
                   let a'  := (if instance_Basic_classes_Eq_nat.= (instance_Num_NumRemainder_nat.mod e 2%nat) 0%nat then a else mul a b) in
                   gen_pow_aux mul a' (mul b b) e''
   end. *)
       
Definition gen_pow {a : Type}   (one : a)  (mul : a ->  a ->  a)  (b : a)  (e : nat )   :  a:=  
  if nat_ltb e( 0%nat) then one else 
  if ( beq_nat e( 0%nat)) then one else gen_pow_aux mul one b e.
(* [?]: removed value specification. *)


Instance x130_NumPow : NumPow nat := { 
   numPow  :=  nat_power
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x129_OrdMaxMin : OrdMaxMin nat := { 
   max  :=  nat_max;
   min  :=  nat_min
}.

(* [?]: removed value specification. *)

(* 

Instance x128_Numeral : Numeral nat := {
   fromNumeral   n :=   n
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x127_Eq : Eq nat := {
   isEqual  :=  beq_nat;
   isInequal   n1  n2 :=  negb (beq_nat n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x126_Ord : Ord nat := {
   compare  :=  (genericCompare nat_ltb beq_nat);
   isLess  :=  nat_ltb;
   isLessEqual  :=  nat_lteb;
   isGreater  :=  nat_gtb;
   isGreaterEqual  :=  nat_gteb
}.


Instance x125_SetType : SetType nat := {
   setElemCompare  :=  (genericCompare nat_ltb beq_nat)
}.

(* [?]: removed value specification. *)


Instance x124_NumAdd : NumAdd nat := {
   numAdd  :=  Coq.Init.Peano.plus
}.

(* [?]: removed value specification. *)


Instance x123_NumMinus : NumMinus nat := {
   numMinus  :=  Coq.Init.Peano.minus
}.

(* [?]: removed value specification. *)

(* 
Definition naturalSucc  (n : nat )  : nat :=  instance_Num_NumAdd_Num_natural.+ n 1%nat. *)
Instance x122_NumSucc : NumSucc nat := {
   succ  :=  S
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x121_NumPred : NumPred nat := {
   pred  :=  Coq.Init.Peano.pred
}.

(* [?]: removed value specification. *)


Instance x120_NumMult : NumMult nat := {
   numMult  :=  Coq.Init.Peano.mult
}.

(* [?]: removed value specification. *)


Instance x119_NumPow : NumPow nat := { 
   numPow  :=  nat_power
}.

(* [?]: removed value specification. *)


Instance x118_NumIntegerDivision : NumIntegerDivision nat := { 
   numIntegerDivision  :=  Nat.div
}.


Instance x117_NumDivision : NumDivision nat := { 
   numDivision  :=  Nat.div
}.

(* [?]: removed value specification. *)


Instance x116_NumRemainder : NumRemainder nat := { 
   numRemainder  :=  Nat.modulo
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x115_OrdMaxMin : OrdMaxMin nat := { 
   max  :=  nat_max;
   min  :=  nat_min
}.

(* [?]: removed value specification. *)

(* 

Instance x114_Numeral : Numeral Z := {
   fromNumeral   n :=  (Z.pred (Z.pos (P_of_succ_nat n)))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x113_Eq : Eq Z := {
   isEqual  :=  Z.eqb;
   isInequal   n1  n2 :=  negb (Z.eqb n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x112_Ord : Ord Z := {
   compare  :=  (genericCompare int_ltb Z.eqb);
   isLess  :=  int_ltb;
   isLessEqual  :=  int_lteb;
   isGreater  :=  int_gtb;
   isGreaterEqual  :=  int_gteb
}.


Instance x111_SetType : SetType Z := {
   setElemCompare  :=  (genericCompare int_ltb Z.eqb)
}.

(* [?]: removed value specification. *)


Instance x110_NumNegate : NumNegate Z := {
   numNegate  :=  (fun  i=>(Coq.ZArith.BinInt.Z.sub Z0 i))
}.

(* [?]: removed value specification. *)
 (* TODO: check *)

Instance x109_NumAbs : NumAbs Z := {
   abs  :=  (fun  input=>(Z.pred (Z.pos (P_of_succ_nat (Z.abs_nat input)))))
}.

(* [?]: removed value specification. *)


Instance x108_NumAdd : NumAdd Z := {
   numAdd  :=  Coq.ZArith.BinInt.Z.add
}.

(* [?]: removed value specification. *)


Instance x107_NumMinus : NumMinus Z := {
   numMinus  :=  Coq.ZArith.BinInt.Z.sub
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x106_NumSucc : NumSucc Z := {
   succ  :=  (fun  n=> Coq.ZArith.BinInt.Z.add n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x105_NumPred : NumPred Z := {
   pred  :=  (fun  n=> Coq.ZArith.BinInt.Z.sub n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)


Instance x104_NumMult : NumMult Z := {
   numMult  :=  Coq.ZArith.BinInt.Z.mul
}.

(* [?]: removed value specification. *)


Instance x103_NumPow : NumPow Z := { 
   numPow  :=  Coq.ZArith.Zpower.Zpower_nat
}.

(* [?]: removed value specification. *)


Instance x102_NumIntegerDivision : NumIntegerDivision Z := { 
   numIntegerDivision  :=  Z.div
}.


Instance x101_NumDivision : NumDivision Z := { 
   numDivision  :=  Z.div
}.

(* [?]: removed value specification. *)


Instance x100_NumRemainder : NumRemainder Z := { 
   numRemainder  :=  Coq.ZArith.Zdiv.Zmod
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x99_OrdMaxMin : OrdMaxMin Z := { 
   max  :=  Z.max;
   min  :=  Z.min
}.

(* [?]: removed value specification. *)

(*   (* TODO: check *)

Instance x98_Numeral : Numeral Z := {
   fromNumeral   n :=  (Z.pred (Z.pos (P_of_succ_nat n)))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x97_Eq : Eq Z := {
   isEqual  :=  Z.eqb;
   isInequal   n1  n2 :=  negb (Z.eqb n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x96_Ord : Ord Z := {
   compare  :=  (genericCompare int_ltb Z.eqb);
   isLess  :=  int_ltb;
   isLessEqual  :=  int_lteb;
   isGreater  :=  int_gtb;
   isGreaterEqual  :=  int_gteb
}.


Instance x95_SetType : SetType Z := {
   setElemCompare  :=  (genericCompare int_ltb Z.eqb)
}.

(* [?]: removed value specification. *)


Instance x94_NumNegate : NumNegate Z := {
   numNegate  :=  (fun  i=>(Coq.ZArith.BinInt.Z.sub Z0 i))
}.

(* [?]: removed value specification. *)

Definition int32Abs  (i : Z )  : Z :=  (if int_lteb((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) i then i else (Coq.ZArith.BinInt.Z.sub Z0 i)).

Instance x93_NumAbs : NumAbs Z := {
   abs  :=  int32Abs
}.

(* [?]: removed value specification. *)


Instance x92_NumAdd : NumAdd Z := {
   numAdd  :=  Coq.ZArith.BinInt.Z.add
}.

(* [?]: removed value specification. *)


Instance x91_NumMinus : NumMinus Z := {
   numMinus  :=  Coq.ZArith.BinInt.Z.sub
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x90_NumSucc : NumSucc Z := {
   succ  :=  (fun  n=> Coq.ZArith.BinInt.Z.add n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x89_NumPred : NumPred Z := {
   pred  :=  (fun  n=> Coq.ZArith.BinInt.Z.sub n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)


Instance x88_NumMult : NumMult Z := {
   numMult  :=  Coq.ZArith.BinInt.Z.mul
}.

(* [?]: removed value specification. *)


Instance x87_NumPow : NumPow Z := { 
   numPow  :=  Coq.ZArith.Zpower.Zpower_nat
}.

(* [?]: removed value specification. *)


Instance x86_NumIntegerDivision : NumIntegerDivision Z := { 
   numIntegerDivision  :=  Z.div
}.


Instance x85_NumDivision : NumDivision Z := { 
   numDivision  :=  Z.div
}.

(* [?]: removed value specification. *)


Instance x84_NumRemainder : NumRemainder Z := { 
   numRemainder  :=  Coq.ZArith.Zdiv.Zmod
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x83_OrdMaxMin : OrdMaxMin Z := { 
   max  :=  Z.max;
   min  :=  Z.min
}.

(* [?]: removed value specification. *)

(*   (* TODO: check *)

Instance x82_Numeral : Numeral Z := {
   fromNumeral   n :=  (Z.pred (Z.pos (P_of_succ_nat n)))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x81_Eq : Eq Z := {
   isEqual  :=  Z.eqb;
   isInequal   n1  n2 :=  negb (Z.eqb n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x80_Ord : Ord Z := {
   compare  :=  (genericCompare int_ltb Z.eqb);
   isLess  :=  int_ltb;
   isLessEqual  :=  int_lteb;
   isGreater  :=  int_gtb;
   isGreaterEqual  :=  int_gteb
}.


Instance x79_SetType : SetType Z := {
   setElemCompare  :=  (genericCompare int_ltb Z.eqb)
}.

(* [?]: removed value specification. *)


Instance x78_NumNegate : NumNegate Z := {
   numNegate  :=  (fun  i=>(Coq.ZArith.BinInt.Z.sub Z0 i))
}.

(* [?]: removed value specification. *)

Definition int64Abs  (i : Z )  : Z :=  (if int_lteb((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) i then i else (Coq.ZArith.BinInt.Z.sub Z0 i)).

Instance x77_NumAbs : NumAbs Z := {
   abs  :=  int64Abs
}.

(* [?]: removed value specification. *)


Instance x76_NumAdd : NumAdd Z := {
   numAdd  :=  Coq.ZArith.BinInt.Z.add
}.

(* [?]: removed value specification. *)


Instance x75_NumMinus : NumMinus Z := {
   numMinus  :=  Coq.ZArith.BinInt.Z.sub
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x74_NumSucc : NumSucc Z := {
   succ  :=  (fun  n=> Coq.ZArith.BinInt.Z.add n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x73_NumPred : NumPred Z := {
   pred  :=  (fun  n=> Coq.ZArith.BinInt.Z.sub n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)


Instance x72_NumMult : NumMult Z := {
   numMult  :=  Coq.ZArith.BinInt.Z.mul
}.

(* [?]: removed value specification. *)


Instance x71_NumPow : NumPow Z := { 
   numPow  :=  Coq.ZArith.Zpower.Zpower_nat
}.

(* [?]: removed value specification. *)


Instance x70_NumIntegerDivision : NumIntegerDivision Z := { 
   numIntegerDivision  :=  Z.div
}.


Instance x69_NumDivision : NumDivision Z := { 
   numDivision  :=  Z.div
}.

(* [?]: removed value specification. *)


Instance x68_NumRemainder : NumRemainder Z := { 
   numRemainder  :=  Coq.ZArith.Zdiv.Zmod
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x67_OrdMaxMin : OrdMaxMin Z := { 
   max  :=  Z.max;
   min  :=  Z.min
}.

(* [?]: removed value specification. *)

(* 

Instance x66_Numeral : Numeral Z := {
   fromNumeral   n :=  (Z.pred (Z.pos (P_of_succ_nat n)))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x65_Eq : Eq Z := {
   isEqual  :=  Z.eqb;
   isInequal   n1  n2 :=  negb (Z.eqb n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x64_Ord : Ord Z := {
   compare  :=  (genericCompare int_ltb Z.eqb);
   isLess  :=  int_ltb;
   isLessEqual  :=  int_lteb;
   isGreater  :=  int_gtb;
   isGreaterEqual  :=  int_gteb
}.


Instance x63_SetType : SetType Z := {
   setElemCompare  :=  (genericCompare int_ltb Z.eqb)
}.

(* [?]: removed value specification. *)


Instance x62_NumNegate : NumNegate Z := {
   numNegate  :=  (fun  i=>(Coq.ZArith.BinInt.Z.sub Z0 i))
}.

(* [?]: removed value specification. *)
 (* TODO: check *)

Instance x61_NumAbs : NumAbs Z := {
   abs  :=  (fun  input=>(Z.pred (Z.pos (P_of_succ_nat (Z.abs_nat input)))))
}.

(* [?]: removed value specification. *)


Instance x60_NumAdd : NumAdd Z := {
   numAdd  :=  Coq.ZArith.BinInt.Z.add
}.

(* [?]: removed value specification. *)


Instance x59_NumMinus : NumMinus Z := {
   numMinus  :=  Coq.ZArith.BinInt.Z.sub
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x58_NumSucc : NumSucc Z := {
   succ  :=  (fun  n=> Coq.ZArith.BinInt.Z.add n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x57_NumPred : NumPred Z := {
   pred  :=  (fun  n=> Coq.ZArith.BinInt.Z.sub n((Z.pred (Z.pos (P_of_succ_nat 1%nat)))))
}.

(* [?]: removed value specification. *)


Instance x56_NumMult : NumMult Z := {
   numMult  :=  Coq.ZArith.BinInt.Z.mul
}.

(* [?]: removed value specification. *)


Instance x55_NumPow : NumPow Z := { 
   numPow  :=  Coq.ZArith.Zpower.Zpower_nat
}.

(* [?]: removed value specification. *)


Instance x54_NumIntegerDivision : NumIntegerDivision Z := { 
   numIntegerDivision  :=  Z.div
}.


Instance x53_NumDivision : NumDivision Z := { 
   numDivision  :=  Z.div
}.

(* [?]: removed value specification. *)


Instance x52_NumRemainder : NumRemainder Z := { 
   numRemainder  :=  Coq.ZArith.Zdiv.Zmod
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x51_OrdMaxMin : OrdMaxMin Z := { 
   max  :=  Z.max;
   min  :=  Z.min
}.

(* [?]: removed value specification. *)

(* 

Instance x50_Numeral : Numeral Q := {
   fromNumeral   n :=  (inject_Z (Z.pred (Z.pos (P_of_succ_nat n))))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x49_Eq : Eq Q := {
   isEqual  :=  Qeq_bool;
   isInequal   n1  n2 :=  negb (Qeq_bool n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x48_Ord : Ord Q := {
   compare  :=  (genericCompare Qlt_bool Qeq_bool);
   isLess  :=  Qlt_bool;
   isLessEqual  :=  Qle_bool;
   isGreater  :=  Qgt_bool;
   isGreaterEqual  :=  Qge_bool
}.


Instance x47_SetType : SetType Q := {
   setElemCompare  :=  (genericCompare Qlt_bool Qeq_bool)
}.

(* [?]: removed value specification. *)


Instance x46_NumAdd : NumAdd Q := {
   numAdd  :=  Qplus
}.

(* [?]: removed value specification. *)


Instance x45_NumMinus : NumMinus Q := {
   numMinus  :=  Qminus
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x44_NumNegate : NumNegate Q := {
   numNegate  :=  (fun  n=> Qminus((inject_Z (Z.pred (Z.pos (P_of_succ_nat 0%nat))))) n)
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x43_NumAbs : NumAbs Q := {
   abs  :=  (fun  n=>(if Qgt_bool n((inject_Z (Z.pred (Z.pos (P_of_succ_nat 0%nat))))) then n else Qminus((inject_Z (Z.pred (Z.pos (P_of_succ_nat 0%nat))))) n))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x42_NumSucc : NumSucc Q := {
   succ  :=  (fun  n=> Qplus n((inject_Z (Z.pred (Z.pos (P_of_succ_nat 1%nat))))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x41_NumPred : NumPred Q := {
   pred  :=  (fun  n=> Qminus n((inject_Z (Z.pred (Z.pos (P_of_succ_nat 1%nat))))))
}.

(* [?]: removed value specification. *)


Instance x40_NumMult : NumMult Q := {
   numMult  :=  Qmult
}.

(* [?]: removed value specification. *)


Instance x39_NumDivision : NumDivision Q := {
   numDivision  :=  Qdiv
}.

(* [?]: removed value specification. *)

Definition rationalFromFrac  (n : Z ) (d : Z )  : Q :=  Qdiv ((inject_Z n)) ((inject_Z d)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 
Program Fixpoint rationalPowInteger  (b : Q ) (e : Z )  : Q := 
  if instance_Basic_classes_Eq_Num_integer.= e 0%nat then 1%nat else
  if instance_Basic_classes_Ord_Num_integer.> e 0%nat then instance_Num_NumMult_Num_rational.* Qpower b (instance_Num_NumMinus_Num_integer.- e 1%nat) b else
  instance_Num_NumDivision_Num_rational./ Qpower b (instance_Num_NumAdd_Num_integer.+ e 1%nat) b. *)
(* [?]: removed value specification. *)

(* 
Definition rationalPowNat  (r : Q ) (e : nat )  : Q :=  Qpower r ((Z.pred (Z.pos (P_of_succ_nat e)))). *)

Instance x38_NumPow : NumPow Q := {
   numPow  :=  (fun  r  e=>(Qpower r (Z.of_nat e)))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x37_OrdMaxMin : OrdMaxMin Q := {
   max  :=  Qmax;
   min  :=  Qmin
}.

(* [?]: removed value specification. *)

(* 

Instance x36_Numeral : Numeral R := {
   fromNumeral   n :=  (IZR (Z.pred (Z.pos (P_of_succ_nat n))))
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x35_Eq : Eq R := {
   isEqual  :=  Reqb;
   isInequal   n1  n2 :=  negb (Reqb n1 n2)
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Instance x34_Ord : Ord R := {
   compare  :=  (genericCompare Rlt_bool Reqb);
   isLess  :=  Rlt_bool;
   isLessEqual  :=  Rle_bool;
   isGreater  :=  Rgt_bool;
   isGreaterEqual  :=  Rge_bool
}.


Instance x33_SetType : SetType R := {
   setElemCompare  :=  (genericCompare Rlt_bool Reqb)
}.

(* [?]: removed value specification. *)


Instance x32_NumAdd : NumAdd R := {
   numAdd  :=  Rplus
}.

(* [?]: removed value specification. *)


Instance x31_NumMinus : NumMinus R := {
   numMinus  :=  Rminus
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x30_NumNegate : NumNegate R := {
   numNegate  :=  Ropp
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x29_NumAbs : NumAbs R := {
   abs  :=  Rabs
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x28_NumSucc : NumSucc R := {
   succ  :=  (fun  n=> Rplus n((IZR (Z.pred (Z.pos (P_of_succ_nat 1%nat))))))
}.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Instance x27_NumPred : NumPred R := {
   pred  :=  (fun  n=> Rminus n((IZR (Z.pred (Z.pos (P_of_succ_nat 1%nat))))))
}.

(* [?]: removed value specification. *)


Instance x26_NumMult : NumMult R := {
   numMult  :=  Rmult
}.

(* [?]: removed value specification. *)


Instance x25_NumDivision : NumDivision R := {
   numDivision  :=  Rdiv
}.

(* [?]: removed value specification. *)

Definition realFromFrac  (n : Z ) (d : Z )  : R :=  Rdiv ((IZR n)) ((IZR d)).
(* [?]: removed value specification. *)

(* 
Program Fixpoint realPowInteger  (b : R ) (e : Z )  : R := 
  if instance_Basic_classes_Eq_Num_integer.= e 0%nat then 1%nat else
  if instance_Basic_classes_Ord_Num_integer.> e 0%nat then instance_Num_NumMult_Num_real.* powerRZ b (instance_Num_NumMinus_Num_integer.- e 1%nat) b else
  instance_Num_NumDivision_Num_real./ powerRZ b (instance_Num_NumAdd_Num_integer.+ e 1%nat) b. *)
(* [?]: removed value specification. *)

(* 
Definition realPowNat  (r : R ) (e : nat )  : R :=  powerRZ r ((Z.pred (Z.pos (P_of_succ_nat e)))). *)

Instance x24_NumPow : NumPow R := {
   numPow  :=  pow
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x23_OrdMaxMin : OrdMaxMin R := {
   max  :=  Rmax;
   min  :=  Rmin
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 
Definition integerSqrt  (i : Z )  : Z :=  Rdown (Rsqrt ((IZR i))). *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition int32FromInteger  (i : Z )  : Z :=  (
  let abs_int32 := (Z.pred (Z.pos (P_of_succ_nat (Z.abs_nat i)))) in
  if ( int_ltb i((Z.pred (Z.pos (P_of_succ_nat 0%nat))))) then ((Coq.ZArith.BinInt.Z.sub Z0 abs_int32)) else abs_int32 
).
(* [?]: removed value specification. *)

Definition int32FromInt  (i : Z )  : Z :=  int32FromInteger ( i).
(* [?]: removed value specification. *)

Definition int32FromInt64  (i : Z )  : Z :=  int32FromInteger ( i).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition int64FromInteger  (i : Z )  : Z :=  (
  let abs_int64 := (Z.pred (Z.pos (P_of_succ_nat (Z.abs_nat i)))) in
  if ( int_ltb i((Z.pred (Z.pos (P_of_succ_nat 0%nat))))) then ((Coq.ZArith.BinInt.Z.sub Z0 abs_int64)) else abs_int64 
).
(* [?]: removed value specification. *)

Definition int64FromInt  (i : Z )  : Z :=  int64FromInteger ( i).
(* [?]: removed value specification. *)

Definition int64FromInt32  (i : Z )  : Z :=  int64FromInteger ( i).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
